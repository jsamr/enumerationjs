<br/>
**Pros & Cons**

✓ flexible solution to the missing `enum` keyword implementation  
✓ enum values are unique  
✓ enum values are read only  
✓ enum values can inherit properties from a prototype given at Enumeration instanciation time.  
✓ you can define as many properties as you wish for each instantiated value (such as 'message', 'info' ...)  
✓ The enumerations are guarantied uniques : you cannot instanciate two enumerations with a same name    
✓ The enumerations are frozen (read-only)  
✓ Each enum value has a unique identifier that you provide at instanciation time, recovorable with `id()` method. You can easely match the instance associated to an identifier with `enumInstance.from(identifier)` which allows easy lightweight serialization.  
✓ You can [hack a class](#hack-da-class--incorporate-as-public-class-fields) to have all the defined values of your Enumeration instance as static fields of this `class`.  
✓ You can [move all the logic inside those enum values](#refactoring) and refactor, avoiding the `if else` mess.  
✗ relies on **ECMAScript 5**  
✗ adds a dependency to **underscore.js**  
✗ the key/identifier of an enum value does not appear explicitly inside the object instance. Those are recoverable via `key()` and `id()` methods. However the `describe()` method returns a string with all those informations. And the `enumInstance.pretty()` returns a string with all the enum values and their associated descriptions.  
 
Critics and suggestions are welcome

**Summary**
>
[1. Basic usage](#basic-usage)  
[2. A prototype for enum values](#a-prototype-for-enum-values)  
[3. Use more complex enum descriptors](#use-more-complex-enum-descriptors)  
[4. Extend your Enumeration with prototype inheritance](#extend-your-enumeration-with-prototype-inheritance)  
[5. Hack da class : incorporate as public class fields](#hack-da-class--incorporate-as-public-class-fields)  
[6. The constructor signature](#the-constructor-signature)  
[7. Refactoring](#refactoring)  


